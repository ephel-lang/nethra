<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">

    <title>Dependent Types</title>

    <meta name="description" content="Dependent Types: From theory to practice">
    <meta name="author" content="Didier Plaindoux">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="revealjs/dist/reset.css">
    <link rel="stylesheet" href="revealjs/dist/reveal.css">
    <link rel="stylesheet" href="revealjs/dist/theme/dracula.css" id="theme">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="revealjs/plugin/highlight/monokai.css">
</head>

<body>

<div class="reveal">

    <!-- Any section element inside of this container is displayed as a slide -->
    <div class="slides">
        <section data-background-color="white" data-background-image="./images/background.jpeg">
        </section>

        <section data-background-color="white" data-background-image="./images/background.jpeg"
                 data-background-opacity="0.2">
            <h3>Dependent Types</h3>
        </section>

        <section data-background-color="white" data-background-image="./images/background.jpeg"
                 data-background-opacity="0.2">
            <h4>Why Dependent Types?</h4>

            <ul>
                <li class="fragment">Reinforcing program security</li>
                <li class="fragment">Critical software</li>
            </ul>
        </section>

        <section data-background-color="white" data-background-image="./images/background.jpeg"
                 data-background-opacity="0.2">
            <h4>Dependent Types and Blockchains</h4>

            <ul>
                <li class="fragment">Tezos with Coq, Cardano with Agda</li>
                <li class="fragment">Tezos byte code (Michelson) with MI-CHO-COQ</li>
                <li class="fragment">Proof of laws e.g. consensus</li>
            </ul>
        </section>

        <section data-background-color="white" data-background-image="./images/background.jpeg"
                 data-background-opacity="0.2">
            <h4>A short definition</h4>

            <p class="fragment">"Dependent type [...] depend on or vary with values" <br> Martin Hoffmann</p>
        </section>

        <!-- section data-background-color="white" data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Dependencies everywhere!</h4>

            <ul>
                <li class="fragment">terms depend on terms aka &lambda;&rightarrow;</li>
                <li class="fragment">terms depend on types aka &lambda;2</li>
                <li class="fragment">types depend on types aka &lambda;Ï‰</li>
                <li class="fragment">types depend on terms aka &lambda;P</li>
            </ul>

            <p class="fragment">All combinations with &lambda;C or Calculus of Constructions</p>
        </section>

        <section data-background-color="white" data-background-image="./images/background.jpeg" data-background-opacity="0.2">

            <h4>The lambda cube</h4>

            <img src="images/Lambda_Cube_img.png">
        </section -->

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h3>Dependent Types</h3>
            <h4>From theory to practice</h4>
            <p> D. Plaindoux</p>
        </section>

        <section>
            <h3> Self </h3>

            <h5> Freelance and akawan collaborator</h5>

            <p><a href="https://bosl.ai">Bosl.ai</a> an AI dedicated to DLP and more </p>
            <p><a href="https://www.kaptngo.com">KaptNgo</a> a SASE ZTNA solution and more </p>
        </section>

        <section data-background-color="white" data-background-image="./images/background.jpeg"
                 data-background-opacity="0.2">
            <h4>Understanding Dependent Types means</h4>

            <ul>
                <li class="fragment">Learn from foundations</li>
                <li class="fragment">Focus on a core calculus</li>â‰¤
                <li class="fragment">Design a core language called <a
                        href="https://github.com/lambe-lang/nethra/">Nethra</a></li>
            </ul>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Formalism introduction</h4>

            <pre><code style="background-color: #00000055" class="language-swift" data-noescape>







            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Formalism introduction</h4>

            <pre><code style="background-color: #00000055" class="language-swift" data-noescape>
  P0 ... Pn      when premisses P0 ... Pn are verified
  ---------      then
  C              we conclude C




            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Formalism introduction</h4>

            <pre><code style="background-color: #00000055" class="language-swift" data-noescape>
  P0 ... Pn      when premisses P0 ... Pn are verified
  ---------      then
  C              we conclude C

  Î“              type bindings { X : T } i.e. hypothesis


            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Formalism introduction</h4>

            <pre><code style="background-color: #00000055" class="language-swift" data-noescape>
  P0 ... Pn      when premisses P0 ... Pn are verified
  ---------      then
  C              we conclude C

  Î“              type bindings { X : T } i.e. hypothesis

  Î“ âŠ¢ A : T      Given Î“, the term A inhabits the type T
            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Language &lambda;1</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    x &in; Variables
    i &in; Identifiers








            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Language &lambda;1</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    x &in; Variables
    i &in; Identifiers

    e ::=
         Î»(x).e                 -- Abstraction
         e e                    -- Application
         x                      -- Variable



            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Language &lambda;1</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    x &in; Variables
    i &in; Identifiers

    e ::=
         Î»(x).e                 -- Abstraction
         e e                    -- Application
         x                      -- Variable
    t ::=
         i                      -- Basic types
         t â†’ t                  -- Function type
            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Functions</h4>

            <p>&lambda;-expressions: abstraction and application</p>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Functional type | <code style="background-color: #00000055" data-noescape>M â†’ N</code></h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    Î“, x : M âŠ¢ b : N
    -------------------
    Î“ âŠ¢ Î»(x).b : M â†’ N





            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Functional type | <code style="background-color: #00000055" data-noescape>M â†’ N</code></h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    Î“, x : M âŠ¢ b : N
    -------------------
    Î“ âŠ¢ Î»(x).b : M â†’ N


    Î“ âŠ¢ f : M â†’ N   Î“ âŠ¢ e : M
    --------------------------
    Î“ âŠ¢ f e : N
            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>&lambda;2 : &lambda;1 and dependent functional type</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    x &in; Variables
    i &in; Identifiers

    e ::=
         Î»(x).e                 -- Abstraction
         e e                    -- Application
         x                      -- Variables
    t ::=
         i                      -- Basic types (int, ...)
         t â†’ t                  -- Function type


            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>&lambda;2 : &lambda;1 and dependent functional type</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    x &in; Variables
    i &in; Identifiers

    e ::=
         Î»(x).e                 -- Abstraction
         e e                    -- Application
         x                      -- Variables

         i                      -- Basic types (int, ...)
         e â†’ e                  -- Function type


            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>&lambda;2 : &lambda;1 and dependent functional type</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    x &in; Variables
    i &in; Identifiers

    e ::=
         Î»(x).e                 -- Abstraction
         e e                    -- Application
         x                      -- Variables

         i                      -- Basic types (int, ...)
         e â†’ e                  -- Function type
         (x:e) â†’ e              -- Dependent functional type
         type                   -- type of type
            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>&lambda;2 : &lambda;1 and dependent functional type</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    x &in; Variables
    i &in; Identifiers

    e ::=
         Î»(x).e                 -- Abstraction
         e e                    -- Application
         x                      -- Variables

         i                      -- Basic types (int, ...)
         e â†’ e                  -- &equiv; (_:e) â†’ e
         (x:e) â†’ e              -- Dependent functional type
         type                   -- type of type
            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Dependent functional type | <code style="background-color: #00000055" data-noescape>(x:M) â†’ N</code>
            </h4>

            <div style="text-align: center;"><p>type of return value varies with its argument</p></div>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    Î“, x : M âŠ¢ b : N
    --------------------------------
    Î“ âŠ¢ Î»(x).b : M â†’ N


    Î“ âŠ¢ f : M â†’ N       Î“ âŠ¢ e : M
    ------------------------------
    Î“ âŠ¢ f e : N





            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Dependent functional type | <code style="background-color: #00000055" data-noescape>(x:M) â†’ N</code>
            </h4>

            <div style="text-align: center;"><p>type of return value varies with its argument</p></div>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    Î“, x : M âŠ¢ b : N
    --------------------------------
    Î“ âŠ¢ Î»(x).b : (_:M) â†’ N


    Î“ âŠ¢ f : (_:M) â†’ N   Î“ âŠ¢ e : M
    ------------------------------
    Î“ âŠ¢ f e : N





            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Dependent functional type | <code style="background-color: #00000055">(x:M) â†’ N</code></h4>

            <div style="text-align: center;"><p>type of return value varies with its argument</p></div>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    Î“, x : M âŠ¢ b : N   Î“ âŠ¢ M : type
    --------------------------------
    Î“ âŠ¢ Î»(x).b : (_:M) â†’ N


    Î“ âŠ¢ f : (_:M) â†’ N   Î“ âŠ¢ e : M
    ------------------------------
    Î“ âŠ¢ f e : N





            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Dependent functional type | <code style="background-color: #00000055">(x:M) â†’ N</code></h4>

            <div style="text-align: center;"><p>type of return value varies with its argument</p></div>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    Î“, x : M âŠ¢ b : N   Î“ âŠ¢ M : type
    --------------------------------
    Î“ âŠ¢ Î»(x).b : (x:M) â†’ N


    Î“ âŠ¢ f : (_:M) â†’ N   Î“ âŠ¢ e : M
    ------------------------------
    Î“ âŠ¢ f e : N





            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Dependent functional type | <code style="background-color: #00000055">(x:M) â†’ N</code></h4>

            <div style="text-align: center;"><p>type of return value varies with its argument</p></div>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    Î“, x : M âŠ¢ b : N   Î“ âŠ¢ M : type
    --------------------------------
    Î“ âŠ¢ Î»(x).b : (x:M) â†’ N


    Î“ âŠ¢ f : (x:M) â†’ N   Î“ âŠ¢ e : M
    ------------------------------
    Î“ âŠ¢ f e : N





            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Dependent functional type | <code style="background-color: #00000055">(x:M) â†’ N</code></h4>

            <div style="text-align: center;"><p>type of return value varies with its argument</p></div>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    Î“, x : M âŠ¢ b : N   Î“ âŠ¢ M : type
    --------------------------------
    Î“ âŠ¢ Î»(x).b : (x:M) â†’ N


    Î“ âŠ¢ f : (x:M) â†’ N   Î“ âŠ¢ e : M
    ------------------------------
    Î“ âŠ¢ f e : N[x:=e]





            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Dependent functional type | <code style="background-color: #00000055">(x:M) â†’ N</code></h4>

            <div style="text-align: center;"><p>type of return value varies with its argument</p></div>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    Î“, x : M âŠ¢ b : N   Î“ âŠ¢ M : type
    --------------------------------
    Î“ âŠ¢ Î»(x).b : (x:M) â†’ N


    Î“ âŠ¢ f : (x:M) â†’ N   Î“ âŠ¢ e : M
    ------------------------------
    Î“ âŠ¢ f e : N[x:=e]


    Î“ âŠ¢ M : ?      Î“, x : M âŠ¢ N : ?
    -----------------------------------
    Î“ âŠ¢ (x:M) â†’ N : ?
            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Dependent functional type | <code style="background-color: #00000055">(x:M) â†’ N</code></h4>

            <div style="text-align: center;"><p>type of return value varies with its argument</p></div>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    Î“, x : M âŠ¢ b : N   Î“ âŠ¢ M : type
    --------------------------------
    Î“ âŠ¢ Î»(x).b : (x:M) â†’ N


    Î“ âŠ¢ f : (x:M) â†’ N   Î“ âŠ¢ e : M
    ------------------------------
    Î“ âŠ¢ f e : N[x:=e]


    Î“ âŠ¢ M : type   Î“, x : M âŠ¢ N : type
    -----------------------------------
    Î“ âŠ¢ (x:M) â†’ N : type
            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Dependent functional type: simple example</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    -- A â†’ B &equiv; (_:A) â†’ B

    sig id_t : ?
    val id_t = Î»(X).X â†’ X






            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Dependent functional type: simple example</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    -- A â†’ B &equiv; (_:A) â†’ B

    sig id_t : type â†’ type
    val id_t = Î»(X).X â†’ X






            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Dependent functional type: simple example</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    -- A â†’ B &equiv; (_:A) â†’ B

    sig id_t : type â†’ type
    val id_t = Î»(X).X â†’ X

    sig combine : (A:type) â†’ A â†’ A â†’ A




            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Dependent functional type: simple example</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    -- A â†’ B &equiv; (_:A) â†’ B

    sig id_t : type â†’ type
    val id_t = Î»(X).X â†’ X

    sig combine : (A:type) â†’ A â†’ A â†’ A

    sig incr : int â†’ int
    val incr = combine int 1

            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Dependent functional type: simple example</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    -- A â†’ B &equiv; (_:A) â†’ B

    sig id_t : type â†’ type
    val id_t = Î»(X).X â†’ X

    sig combine : (A:type) â†’ A â†’ A â†’ A

    sig incr : id_t int
    val incr = combine int 1

            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Dependent functional type: intuitive example</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    -- A â†’ B &equiv; (_:A) â†’ B

    sig select : int â†’ type
    -- with select 0 = string and
    --      select i = char for i != 0






            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Dependent functional type: intuitive example</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    -- A â†’ B &equiv; (_:A) â†’ B

    sig select : int â†’ type
    -- with select 0 = string and
    --      select i = char for i != 0

    sig aString : string
    val aString = "Hello World ğŸ‘‹"

    sig aChar   : char
    val aChar   = 'ğŸ˜€'
            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Dependent functional type: intuitive example</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    -- A â†’ B &equiv; (_:A) â†’ B

    sig select : int â†’ type
    -- with select 0 = string and
    --      select i = char for i != 0

    sig aString : select 0
    val aString = "Hello World ğŸ‘‹"

    sig aChar   : select 1
    val aChar   = 'ğŸ˜€'
            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4> Pairs </h4>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>&lambda;3: Language &lambda;2 and pair type</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    e ::=
         ...
         e , e                  -- Pair



         ...
         e * e                  -- Pair type

            </code></pre>
        </section>


        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>&lambda;3: Language &lambda;2 and pair type</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    e ::=
         ...
         e , e                  -- Pair
         fst e                  -- Left projection
         snd e                  -- Right projection

         ...
         e * e                  -- Pair type

            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Pair type | <code style="background-color: #00000055" data-noescape>M * N</code></h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    Î“ âŠ¢ a : M   Î“ âŠ¢ b : N
    ----------------------
    Î“ âŠ¢ a , b : M * N


    Î“ âŠ¢ e : M * N           Î“ âŠ¢ e : M * N
    --------------          ----------------
    Î“ âŠ¢ fst e : M           Î“ âŠ¢ snd e : N
            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>&lambda;3: Language &lambda;2 and dependent pair type</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    e ::=
         ...
         e , e                  -- Pair
         fst e                  -- Left projection
         snd e                  -- Right projection

         ...
         e * e                  -- Pair type

            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>&lambda;3: Language &lambda;2 and dependent pair type</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    e ::=
         ...
         e , e                  -- Pair
         fst e                  -- Left projection
         snd e                  -- Right projection

         ...
         e * e                  -- Pair type
         (x:e) * e              -- Dependent pair type
            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>&lambda;3: Language &lambda;2 and dependent pair type</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    e ::=
         ...
         e , e                  -- Pair
         fst e                  -- Left projection
         snd e                  -- Right projection

         ...
         e * e                  -- &equiv; (_:e) * e
         (x:e) * e              -- Dependent pair type
            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Dependent pair type | <code style="background-color: #00000055" data-noescape>(x:M) * N</code></h4>

            <div style="text-align: center;"><p>type of right value varies with its left value</p></div>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    Î“ âŠ¢ a : M   Î“ âŠ¢ b : N
    -------------------------------------------
    Î“ âŠ¢ a , b : M * N


    Î“ âŠ¢ p : M * N              Î“ âŠ¢ p : M * N
    ------------------         -----------------------
    Î“ âŠ¢ fst p : M              Î“ âŠ¢ snd p : N





            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Dependent pair type | <code style="background-color: #00000055" data-noescape>(x:M) * N</code></h4>

            <div style="text-align: center;"><p>type of right value varies with its left value</p></div>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    Î“ âŠ¢ a : M   Î“ âŠ¢ b : N
    -------------------------------------------
    Î“ âŠ¢ a , b : (_:M) * N


    Î“ âŠ¢ p : (_:M) * N          Î“ âŠ¢ p : (_:M) * N
    ------------------         -----------------------
    Î“ âŠ¢ fst p : M              Î“ âŠ¢ snd p : N





            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Dependent pair type | <code style="background-color: #00000055" data-noescape>(x:M) * N</code></h4>

            <div style="text-align: center;"><p>type of right value varies with its left value</p></div>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    Î“ âŠ¢ a : M   Î“ âŠ¢ b : N
    -------------------------------------------
    Î“ âŠ¢ a , b : (x:M) * N


    Î“ âŠ¢ p : (_:M) * N          Î“ âŠ¢ p : (_:M) * N
    ------------------         -----------------------
    Î“ âŠ¢ fst p : M              Î“ âŠ¢ snd p : N





            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Dependent pair type | <code style="background-color: #00000055" data-noescape>(x:M) * N</code></h4>

            <div style="text-align: center;"><p>type of right value varies with its left value</p></div>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    Î“ âŠ¢ a : M   Î“ âŠ¢ b : N         Î“ âŠ¢ M : type
    -------------------------------------------
    Î“ âŠ¢ a , b : (x:M) * N


    Î“ âŠ¢ p : (_:M) * N          Î“ âŠ¢ p : (_:M) * N
    ------------------         -----------------------
    Î“ âŠ¢ fst p : M              Î“ âŠ¢ snd p : N





            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Dependent pair type | <code style="background-color: #00000055" data-noescape>(x:M) * N</code></h4>

            <div style="text-align: center;"><p>type of right value varies with its left value</p></div>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    Î“ âŠ¢ a : M   Î“ âŠ¢ b : N[x:=a]   Î“ âŠ¢ M : type
    -------------------------------------------
    Î“ âŠ¢ a , b : (x:M) * N


    Î“ âŠ¢ p : (_:M) * N          Î“ âŠ¢ p : (_:M) * N
    ------------------         -----------------------
    Î“ âŠ¢ fst p : M              Î“ âŠ¢ snd p : N





            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Dependent pair type | <code style="background-color: #00000055" data-noescape>(x:M) * N</code></h4>

            <div style="text-align: center;"><p>type of right value varies with its left value</p></div>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    Î“ âŠ¢ a : M   Î“ âŠ¢ b : N[x:=a]   Î“ âŠ¢ M : type
    -------------------------------------------
    Î“ âŠ¢ a , b : (x:M) * N


    Î“ âŠ¢ p : (x:M) * N          Î“ âŠ¢ p : (_:M) * N
    ------------------         -----------------------
    Î“ âŠ¢ fst p : M              Î“ âŠ¢ snd p : N





            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Dependent pair type | <code style="background-color: #00000055" data-noescape>(x:M) * N</code></h4>

            <div style="text-align: center;"><p>type of right value varies with its left value</p></div>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    Î“ âŠ¢ a : M   Î“ âŠ¢ b : N[x:=a]   Î“ âŠ¢ M : type
    -------------------------------------------
    Î“ âŠ¢ a , b : (x:M) * N


    Î“ âŠ¢ p : (x:M) * N          Î“ âŠ¢ p : (x:M) * N
    ------------------         -----------------------
    Î“ âŠ¢ fst p : M              Î“ âŠ¢ snd p : N





            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Dependent pair type | <code style="background-color: #00000055" data-noescape>(x:M) * N</code></h4>

            <div style="text-align: center;"><p>type of right value varies with its left value</p></div>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    Î“ âŠ¢ a : M   Î“ âŠ¢ b : N[x:=a]   Î“ âŠ¢ M : type
    -------------------------------------------
    Î“ âŠ¢ a , b : (x:M) * N


    Î“ âŠ¢ p : (x:M) * N          Î“ âŠ¢ p : (x:M) * N
    ------------------         -----------------------
    Î“ âŠ¢ fst p : M              Î“ âŠ¢ snd p : N[x:=fst p]





            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Dependent pair type | <code style="background-color: #00000055" data-noescape>(x:M) * N</code></h4>

            <div style="text-align: center;"><p>type of right value varies with its left value</p></div>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    Î“ âŠ¢ a : M   Î“ âŠ¢ b : N[x:=a]   Î“ âŠ¢ M : type
    -------------------------------------------
    Î“ âŠ¢ a , b : (x:M) * N


    Î“ âŠ¢ p : (x:M) * N          Î“ âŠ¢ p : (x:M) * N
    ------------------         -----------------------
    Î“ âŠ¢ fst p : M              Î“ âŠ¢ snd p : N[x:=fst p]


    Î“ âŠ¢ M : type   Î“, x : M âŠ¢ N : type
    -----------------------------------
    Î“ âŠ¢ (x:M) * N : type
            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Dependent pair type: simple example</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    sig pair : ?
    val pair = char,'ğŸ¶'






            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Dependent pair type: simple example</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    sig pair : type * char
    val pair = char,'ğŸ¶'






            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Dependent pair type: simple example</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    sig pair : (_:type) * char
    val pair = char,'ğŸ¶'






            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Dependent pair type: simple example</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    sig pair : (x:type) * char
    val pair = char,'ğŸ¶'






            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Dependent pair type: simple example</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    sig pair : (x:type) * x
    val pair = char,'ğŸ¶'






            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Dependent pair type: simple example</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    sig pair : (x:type) * x
    val pair = char,'ğŸ¶'

    sig first : type
    val first = fst pair



            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Dependent pair type: simple example</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    sig pair : (x:type) * x
    val pair = char,'ğŸ¶'

    sig first : type
    val first = fst pair

    sig second : ?
    val second = snd pair
            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Dependent pair type: simple example</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    sig pair : (x:type) * x
    val pair = char,'ğŸ¶'

    sig first : type
    val first = fst pair

    sig second : char
    val second = snd pair
            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Dependent pair type: simple example</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    sig pair : (x:type) * x
    val pair = char,'ğŸ¶'

    sig first : type
    val first = fst pair

    sig second : char -- char &equiv; fst pair (i.e. x[x:=fst pair])
    val second = snd pair
            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Dependent pair type: simple example</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    sig pair : (x:type) * x
    val pair = char,'ğŸ¶'

    sig first : type
    val first = fst pair

    sig second : fst pair
    val second = snd pair
            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Dependent pair type: simple example</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    sig pair : (x:type) * x
    val pair = char,'ğŸ¶'

    sig first : type
    val first = fst pair

    sig second : first
    val second = snd pair
            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Sum</h4>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>&lambda;4: Language &lambda;3 and sum type</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    x &in; Variables

    e ::=
         ...




         ...
         e + e                  -- Sum type
            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>&lambda;4: Language &lambda;3 and sum type</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    x &in; Variables

    e ::=
         ...
         inl e                  -- Left injection
         inr e                  -- Right injection
         case x e e             -- Catamorphism

         ...
         e + e                  -- Sum type
            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Sum type: A quick but complete example</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    sig bool : type
    val bool = Unit + Unit









            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Sum type: A quick but complete example</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    sig bool : type
    val bool = Unit + Unit

    sig true  : bool
    val true  = inl unit

    sig false : bool
    val false = inr unit



            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Sum type: A quick but complete example</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    sig bool : type
    val bool = Unit + Unit

    sig true  : bool
    val true  = inl unit

    sig false : bool
    val false = inr unit

    sig if : (A:type) -> bool -> (Unit -> A) -> (Unit -> A) â†’ A
    val if = Î»(_).Î»(cond).Î»(then).Î»(else).case cond then else
            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Sum type</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    Î“ âŠ¢ a : ?                  Î“ âŠ¢ a : ?
    ------------------         ------------------
    Î“ âŠ¢ inl a : ?              Î“ âŠ¢ inr a : ?


    Î“ âŠ¢ a : ?
    Î“ âŠ¢ l : ?                    Î“ âŠ¢ r : ?
    ----------------------------------------------------------
    Î“ âŠ¢ case a l r : P





            </code></pre>

        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Sum type</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    Î“ âŠ¢ a : M                  Î“ âŠ¢ a : ?
    ------------------         ------------------
    Î“ âŠ¢ inl a : M + N          Î“ âŠ¢ inr a : ?


    Î“ âŠ¢ a : ?
    Î“ âŠ¢ l : ?                    Î“ âŠ¢ r : ?
    ----------------------------------------------------------
    Î“ âŠ¢ case a l r : P





            </code></pre>

        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Sum type</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    Î“ âŠ¢ a : M                  Î“ âŠ¢ a : N
    ------------------         ------------------
    Î“ âŠ¢ inl a : M + N          Î“ âŠ¢ inr a : M + N


    Î“ âŠ¢ a : ?
    Î“ âŠ¢ l : ?                    Î“ âŠ¢ r : ?
    ----------------------------------------------------------
    Î“ âŠ¢ case a l r : P





            </code></pre>

        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Sum type</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    Î“ âŠ¢ a : M                  Î“ âŠ¢ a : N
    ------------------         ------------------
    Î“ âŠ¢ inl a : M + N          Î“ âŠ¢ inr a : M + N


    Î“ âŠ¢ a : M + N
    Î“ âŠ¢ l : M â†’ P                 Î“ âŠ¢ r : N â†’ P
    ----------------------------------------------------------
    Î“ âŠ¢ case a l r : P





            </code></pre>

        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Sum type</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    Î“ âŠ¢ a : M                  Î“ âŠ¢ a : N
    ------------------         ------------------
    Î“ âŠ¢ inl a : M + N          Î“ âŠ¢ inr a : M + N


    Î“ âŠ¢ a : M + N
    Î“ âŠ¢ l : (_:M) â†’ P             Î“ âŠ¢ r : (_:N) â†’ P
    ----------------------------------------------------------
    Î“ âŠ¢ case a l r : P





            </code></pre>

        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Sum type</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    Î“ âŠ¢ a : M                  Î“ âŠ¢ a : N
    ------------------         ------------------
    Î“ âŠ¢ inl a : M + N          Î“ âŠ¢ inr a : M + N


    Î“ âŠ¢ a : M + N                 x &notin; fv(P)
    Î“ âŠ¢ l : (x:M) â†’ P             Î“ âŠ¢ r : (x:N) â†’ P
    ----------------------------------------------------------
    Î“ âŠ¢ case a l r : P





            </code></pre>

        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Sum type</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    Î“ âŠ¢ a : M                  Î“ âŠ¢ a : N
    ------------------         ------------------
    Î“ âŠ¢ inl a : M + N          Î“ âŠ¢ inr a : M + N


    Î“ âŠ¢ a : M + N                 x &notin; fv(P)
    Î“ âŠ¢ l : (x:M) â†’ P[a:=inl x]   Î“ âŠ¢ r : (x:N) â†’ P[a:=inr x]
    ----------------------------------------------------------
    Î“ âŠ¢ case a l r : P





            </code></pre>

        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Sum type</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    Î“ âŠ¢ a : M                  Î“ âŠ¢ a : N
    ------------------         ------------------
    Î“ âŠ¢ inl a : M + N          Î“ âŠ¢ inr a : M + N


    Î“ âŠ¢ a : M + N                 x &notin; fv(P)
    Î“ âŠ¢ l : (x:M) â†’ P[a:=inl x]   Î“ âŠ¢ r : (x:N) â†’ P[a:=inr x]
    ----------------------------------------------------------
    Î“ âŠ¢ case a l r : P


    Î“ âŠ¢ M : type    Î“ âŠ¢ N : type
    -----------------------------
    Î“ âŠ¢ M + N : type
            </code></pre>

        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Sum type: simple example</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    sig int_or_char : int + char â†’ type
    val int_or_char = Î»(x).case x Î»(_).char Î»(_).int

    sig aChar : char
    val aChar = 'ğŸŒŠ'
            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Sum type: simple example</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    sig int_or_char : int + char â†’ type
    val int_or_char = Î»(x).case x Î»(_).char Î»(_).int

    sig aChar : int_or_char (inl 1)
    val aChar = 'ğŸŒŠ'
            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Sum type: advanced example</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    sig bool : type
    val bool = Unit + Unit











            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Sum type: advanced example</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    sig bool : type
    val bool = Unit + Unit

    sig true  : bool
    val true  = inl unit
    sig false : bool
    val false = inr unit






            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Sum type: advanced example</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    sig bool : type
    val bool = Unit + Unit

    sig true  : bool
    val true  = inl unit
    sig false : bool
    val false = inr unit

    sig Test : bool â†’ type
    val Test = Î»(b).case b Î»(_).int Î»(_).char



            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Sum type: advanced example</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    sig bool : type
    val bool = Unit + Unit

    sig true  : bool
    val true  = inl unit
    sig false : bool
    val false = inr unit

    sig Test : bool â†’ type
    val Test = Î»(b).case b Î»(_).int Î»(_).char

    sig test : (b:bool) â†’ ?
    val test = Î»(c).case c Î»(_).42 Î»(_).'*'
            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Sum type: advanced example</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    sig bool : type
    val bool = Unit + Unit

    sig true  : bool
    val true  = inl unit
    sig false : bool
    val false = inr unit

    sig Test : bool â†’ type
    val Test = Î»(b).case b Î»(_).int Î»(_).char

    sig test : (b:bool) â†’ Test b
    val test = Î»(c).case c Î»(_).42 Î»(_).'*'
            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Propositional Equality</h4>

            <ul>
                <li class="fragment" data-fragment-index="1">Intentional type theory</li>
                <li class="fragment" data-fragment-index="3">Observational type theory</li>
                <li class="fragment" data-fragment-index="2">Extensional type theory</li>
                <li class="fragment" data-fragment-index="4">Homotopy type theory</li>
            </ul>

            <p></p>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>&lambda;5: Language &lambda;4 and propositional equality</h4>

            <p> Intentional type theory </p>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    e ::=
         ...
         refl                   -- Reflexivity


         ...
         e :=: e                  -- type equality
            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>&lambda;5: Language &lambda;4 and propositional equality</h4>

            <p> Intentional type theory </p>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    e ::=
         ...
         refl                   -- Reflexivity
         subst e by e           -- Substitution

         ...
         e :=: e                  -- type equality
            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Propositional equality</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    Î“ âŠ¢ n : A    Î“ âŠ¢ m : A
    -----------------------
    Î“ âŠ¢ n :=: m : type










            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Propositional equality</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    Î“ âŠ¢ n : A    Î“ âŠ¢ m : A
    -----------------------           -------------------
    Î“ âŠ¢ n :=: m : type                Î“ âŠ¢ refl : m :=: m










            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Propositional equality</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    Î“ âŠ¢ n : A    Î“ âŠ¢ m : A
    -----------------------           -------------------
    Î“ âŠ¢ n :=: m : type                Î“ âŠ¢ refl : m :=: m


    Î“ âŠ¢ b : x :=: B    Î“ âŠ¢ a : A[x:=B]
    ----------------------------------
    Î“ âŠ¢ subst a by b : A


    Î“ âŠ¢ b : B :=: x    Î“ âŠ¢ a : A[x:=B]
    ----------------------------------
    Î“ âŠ¢ subst a by b : A
            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Propositional equality: simple example</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    sig reflexive : (A:type) â†’ (a:A) â†’ a :=: a
    val reflexive = &lambda;(A).&lambda;(a).refl



            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Propositional equality: simple example</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    sig reflexive : (A:type) â†’ (a:A) â†’ a :=: a
    val reflexive = &lambda;(A).&lambda;(a).refl

    sig symmetric : (A:type) â†’ (a:A) â†’ (b:A) â†’ a :=: b â†’ b :=: a
    val symmetric = &lambda;(A).&lambda;(a).&lambda;(b).&lambda;(a=b).?
            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Propositional equality: simple example</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    sig reflexive : (A:type) â†’ (a:A) â†’ a :=: a
    val reflexive = &lambda;(A).&lambda;(a).refl

    sig symmetric : (A:type) â†’ (a:A) â†’ (b:A) â†’ a :=: b â†’ b :=: a
    val symmetric = &lambda;(A).&lambda;(a).&lambda;(b).&lambda;(a=b).(subst refl by a=b)
            </code></pre>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Propositional equality: Proving laws</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    val bool  : type = Unit + Unit
    val true  : bool = inl unit
    val false : bool = inr unit






            </code></pre>

        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Propositional equality: Proving laws</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    val bool  : type = Unit + Unit
    val true  : bool = inl unit
    val false : bool = inr unit

    sig and : bool â†’ bool â†’ bool
    val and = &lambda;(a).&lambda;(b).case a &lambda;(_).b &lambda;(_).false



            </code></pre>

        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Propositional equality: Proving laws</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    val bool  : type = Unit + Unit
    val true  : bool = inl unit
    val false : bool = inr unit

    sig and : bool â†’ bool â†’ bool
    val and = &lambda;(a).&lambda;(b).case a &lambda;(_).b &lambda;(_).false

    sig `and true b = b` : (b:bool) â†’ and true b :=: b
    val `and true b = b` = &lambda;(b).?
            </code></pre>

        </section>
        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Propositional equality: Proving laws</h4>

            <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
    val bool  : type = Unit + Unit
    val true  : bool = inl unit
    val false : bool = inr unit

    sig and : bool â†’ bool â†’ bool
    val and = &lambda;(a).&lambda;(b).case a &lambda;(_).b &lambda;(_).false

    sig `and true b = b` : (b:bool) â†’ and true b :=: b
    val `and true b = b` = &lambda;(b).refl
            </code></pre>

        </section>

        <!--
                <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
                    <h4>Propositional equality: encoding GADT</h4>

                    <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
            -{
             data Expr A =
             | Boolean of bool with A = bool
             | Integer of int  with A = int
            }-

            sig Expr : type â†’ type
            val Expr = ?



                    </code></pre>
                </section>

                <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
                    <h4>Propositional equality: encoding GADT</h4>

                    <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
            -{
             data Expr A =
             | Boolean of bool with A = bool
             | Integer of int  with A = int
            }-

            sig Expr : type â†’ type
            val Expr = &lambda;(A).((A :=: bool) * bool) + ((A :=: int) * int)



                    </code></pre>
                </section>

                <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
                    <h4>Propositional equality: encoding GADT</h4>

                    <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
            sig Expr : type â†’ type
            val Expr = &lambda;(A).((A :=: bool) * bool) + ((A :=: int) * int)









                    </code></pre>
                </section>

                <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
                    <h4>Propositional equality: encoding GADT</h4>

                    <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
            sig Expr : type â†’ type
            val Expr = &lambda;(A).((A :=: bool) * bool) + ((A :=: int) * int)

            sig Boolean : (A:type) â†’ A :=: bool â†’ bool â†’ Expr A
            val Boolean = &lambda;(_).&lambda;(p).&lambda;(b).inl (p,b)






                    </code></pre>
                </section>

                <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
                    <h4>Propositional equality: encoding GADT</h4>

                    <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
            sig Expr : type â†’ type
            val Expr = &lambda;(A).((A :=: bool) * bool) + ((A :=: int) * int)

            sig Boolean : (A:type) â†’ A :=: bool â†’ bool â†’ Expr A
            val Boolean = &lambda;(_).&lambda;(p).&lambda;(b).inl (p,b)

            sig Integer : (A:type) â†’ A :=: int â†’ int â†’ Expr A
            val Integer = &lambda;(_).&lambda;(p).&lambda;(i).inr (p,i)



                    </code></pre>
                </section>

                <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
                    <h4>Propositional equality: encoding GADT</h4>

                    <pre><code style="background-color: #00000055" class="language-nethra" data-noescape>
            sig Expr : type â†’ type
            val Expr = &lambda;(A).((A :=: bool) * bool) + ((A :=: int) * int)

            sig Boolean : (A:type) â†’ A :=: bool â†’ bool â†’ Expr A
            val Boolean = &lambda;(_).&lambda;(p).&lambda;(b).inl (p,b)

            sig Integer : (A:type) â†’ A :=: int â†’ int â†’ Expr A
            val Integer = &lambda;(_).&lambda;(p).&lambda;(i).inr (p,i)

            sig one_expr : Expr int
            val one_expr : Integer int refl 1
                    </code></pre>
                </section>
        -->
        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Not covered in this presentation</h4>

            <ul>
                <li class="fragment">Implicits and simple type synthesis</li>
                <li class="fragment">Dependent recursive type</li>
                <li class="fragment">Dependent record type (Pair generalisation)</li>
                <li class="fragment">Russell's Paradox</li>
            </ul>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4> Conclusion </h4>

            <p class="fragment"> Think different! </p>
        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Languages with dependent types</h4>

            <ul>
                <li> Coq</li>
                <li> Agda</li>
                <li> Idris</li>
                <li> Lean</li>
                <li> F*</li>
                <li> Granule</li>
                <li> ...</li>
            </ul>

        </section>

        <section data-background-image="./images/background.jpeg" data-background-opacity="0.2">
            <h4>Some references</h4>

            <ul>
                <li>
                    <a href="https://archive.wikiwix.com/cache/display2.php?url=http%3A%2F%2Fdare.ubn.kun.nl%2Fdspace%2Fbitstream%2F2066%2F17240%2F1%2F13256.pdf">Introduction
                        to generalized type systems </a></li>
                <li><a href="https://hal.inria.fr/inria-00076024/document">The calculus of constructions</a>
                <li>
                    <a href="https://www.irif.fr/~mellies/mpri/mpri-ens/articles/hofmann-syntax-and-semantics-of-dependent-types.pdf">Syntax
                        and semantics of dependent types</a></li>
                <li><a href="https://www.academia.edu/51788443/A_simple_type_theoretic_language_Mini_TT">A simple
                    type-theoretic language:
                    Mini-TT</a>
                <li><a href="http://www.cs.nott.ac.uk/~psztxa/publ/pisigma-new.pdf">Î Î£: Dependent Types without the
                    Sugar</a>
                <li><a href="https://dl.acm.org/doi/pdf/10.1145/289423.289451">Cayenne a language with dependent
                    types</a>
                <li><a href="https://arxiv.org/pdf/2207.02129.pdf">Implementing Dependent Types in pi-forall</a>
                <li><a href="https://homotopytypetheory.org/book/">Homotopy Type Theory</a>
                <li><a href="https://nextjournal.com/zampino/russell-paradox">Russell's Paradox - Agda Edition</a></li>
            </ul>
        </section>

    </div>

</div>

<script src="revealjs/dist/reveal.js"></script>
<script src="revealjs/plugin/zoom/zoom.js"></script>
<script src="revealjs/plugin/notes/notes.js"></script>
<script src="revealjs/plugin/search/search.js"></script>
<script src="revealjs/plugin/markdown/markdown.js"></script>
<script src="revealjs/plugin/highlight/highlight.js"></script>
<script src="extension/nethra.js"></script>

<script>
    // Also available as an ES module, see:
    // https://revealjs.com/initialization/
    Reveal.initialize({
        controls: false,
        progress: false,
        center: true,
        hash: true,
        transition: 'none',

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight]
    });

    nethra(RevealHighlight);
</script>

</body>
</html>
