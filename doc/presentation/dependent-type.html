<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">

    <title>reveal.js ‚Äì The HTML Presentation Framework</title>

    <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
    <meta name="author" content="Hakim El Hattab">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="revealjs/dist/reset.css">
    <link rel="stylesheet" href="revealjs/dist/reveal.css">
    <link rel="stylesheet" href="revealjs/dist/theme/dracula.css" id="theme">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="revealjs/plugin/highlight/monokai.css">
</head>

<body>

<div class="reveal">

    <!-- Any section element inside of this container is displayed as a slide -->
    <div class="slides">
        <section data-background-color="white">
            <h3>Understanding Dependent Types</h3>
            <p><img src="images/MySelf.png"></p>
        </section>

        <section>

            <h4>A short definition</h4>

            <p>A dependent type is a type whose <br> definition depends on a value</p>

        </section>

        <section>

            <h4>Dependencies everywhere!</h4>

            <ul>
                <li class="fragment">terms depend on terms aka &lambda;&rightarrow;</li>
                <li class="fragment">terms depend on types aka &lambda;2</li>
                <li class="fragment">types depend on types aka &lambda;œâ</li>
                <li class="fragment">types depend on terms aka &lambda;P</li>
            </ul>

            <p class="fragment">All combinations with &lambda;C or Calculus of Constructions</p>

        </section>

        <section data-background-color="white">

            <h4>The lambda cube</h4>

            <img src="images/Lambda_Cube_img.png">
        </section>

        <section>
            <h4>‚òïÔ∏è &nbsp; Break</h4>

            <pre><code class="language-swift" data-noescape>







            </code></pre>
        </section>

        <section>
            <h4>‚òïÔ∏è &nbsp; Break</h4>

            <pre><code class="language-swift" data-noescape>
  P0 ... Pn      when premisses P0 ... Pn are verified
  ---------      then
  C              we conclude C




            </code></pre>
        </section>

        <section>
            <h4>‚òïÔ∏è &nbsp; Break</h4>

            <pre><code class="language-swift" data-noescape>
  P0 ... Pn      when premisses P0 ... Pn are verified
  ---------      then
  C              we conclude C

  Œì              type bindings i.e. hypothesis


            </code></pre>
        </section>

        <section>
            <h4>‚òïÔ∏è &nbsp; Break</h4>

            <pre><code class="language-swift" data-noescape>
  P0 ... Pn      when premisses P0 ... Pn are verified
  ---------      then
  C              we conclude C

  Œì              type bindings i.e. hypothesis

  Œì ‚ä¢ A : T      given Œì, the term A inhabits the type T
            </code></pre>
        </section>

        <section>
            <h4>Language &lambda;1</h4>

            <pre><code class="language-ocaml" data-noescape>
    x &in; Variables
    i &in; Identifiers

    e ::=
         Œª(x).e                 -- Abstraction
         e e                    -- Application
         x                      -- Variable
    t ::=
         i                      -- Basic types (int, ...)
         t ‚Üí t                  -- Function type
            </code></pre>
        </section>

        <section>
            <h4>Functions</h4>

            <p>&lambda;-expressions: abstraction and application</p>
        </section>

        <section>
            <h4>Functional type | <code data-noescape>M ‚Üí N</code></h4>

            <pre><code class="language-ocaml" data-noescape>
    Œì, x : M ‚ä¢ b : N
    -------------------
    Œì ‚ä¢ Œª(x).b : M ‚Üí N




            </code></pre>
        </section>

        <section>
            <h4>Functional type | <code data-noescape>M ‚Üí N</code></h4>

            <pre><code class="language-ocaml" data-noescape>
    Œì, x : M ‚ä¢ b : N
    -------------------
    Œì ‚ä¢ Œª(x).b : M ‚Üí N

    Œì ‚ä¢ f : M ‚Üí N   Œì ‚ä¢ e : M
    --------------------------
    Œì ‚ä¢ f e : N
            </code></pre>
        </section>

        <section>
            <h4>&lambda;2 : &lambda;1 and dependant functional type</h4>

            <pre><code class="language-ocaml" data-noescape>
    x &in; Variables
    i &in; Identifiers

    e ::=
         Œª(x).e                 -- Abstraction
         e e                    -- Application
         x                      -- Variables
    t ::=
         i                      -- Basic types (int, ...)
         t ‚Üí t                  -- Function type


            </code></pre>
        </section>

        <section>
            <h4>&lambda;2 : &lambda;1 and dependant functional type</h4>

            <pre><code class="language-ocaml" data-noescape>
    x &in; Variables
    i &in; Identifiers

    e ::=
         Œª(x).e                 -- Abstraction
         e e                    -- Application
         x                      -- Variables

         i                      -- Basic types (int, ...)
         e ‚Üí e                  -- Function type


            </code></pre>
        </section>

        <section>
            <h4>&lambda;2 : &lambda;1 and dependant functional type</h4>

            <pre><code class="language-ocaml" data-noescape>
    x &in; Variables
    i &in; Identifiers

    e ::=
         Œª(x).e                 -- Abstraction
         e e                    -- Application
         x                      -- Variables

         i                      -- Basic types (int, ...)
         e ‚Üí e                  -- &equiv; Œ†(_:e).e
         Œ†(x:e).e               -- Dependent functional type
         type                   -- type of type
            </code></pre>
        </section>

        <section>
            <h4>Dependent functional type | <code data-noescape>&Pi;(x:M).N</code></h4>

            <center><p>type of return value varies with its argument</p></center>

            <pre class="fragment"><code class="language-ocaml" data-noescape>
    Œì, x : ? ‚ä¢ b : ?
    ----------------------
    Œì ‚ä¢ Œª(x).b : ?

    Œì ‚ä¢ f : ?          Œì ‚ä¢ e : ?
    -----------------------------
    Œì ‚ä¢ f e : ?




            </code></pre>
        </section>

        <section>
            <h4>Dependent functional type | <code>&Pi;(x:M).N</code></h4>

            <center><p>type of return value varies with its argument</p></center>

            <pre><code class="language-ocaml" data-noescape>
    Œì, x : M ‚ä¢ b : N
    ----------------------
    Œì ‚ä¢ Œª(x).b : Œ†(?:M).N

    Œì ‚ä¢ f : ?          Œì ‚ä¢ e : ?
    -----------------------------
    Œì ‚ä¢ f e : ?




            </code></pre>
        </section>

        <section>
            <h4>Dependent functional type | <code>&Pi;(x:M).N</code></h4>

            <center><p>type of return value varies with its argument</p></center>

            <pre><code class="language-ocaml" data-noescape>
    Œì, x : M ‚ä¢ b : N
    ----------------------
    Œì ‚ä¢ Œª(x).b : Œ†(x:M).N

    Œì ‚ä¢ f : ?          Œì ‚ä¢ e : ?
    -----------------------------
    Œì ‚ä¢ f e : ?




            </code></pre>
        </section>

        <section>
            <h4>Dependent functional type | <code>&Pi;(x:M).N</code></h4>

            <center><p>type of return value varies with its argument</p></center>

            <pre><code class="language-ocaml" data-noescape>
    Œì, x : M ‚ä¢ b : N
    ----------------------
    Œì ‚ä¢ Œª(x).b : Œ†(x:M).N

    Œì ‚ä¢ f : Œ†(x:M).N   Œì ‚ä¢ e : M
    -----------------------------
    Œì ‚ä¢ f e : N




            </code></pre>
        </section>

        <section>
            <h4>Dependent functional type | <code>&Pi;(x:M).N</code></h4>

            <center><p>type of return value varies with its argument</p></center>

            <pre><code class="language-ocaml" data-noescape>
    Œì, x : M ‚ä¢ b : N
    ----------------------
    Œì ‚ä¢ Œª(x).b : Œ†(x:M).N

    Œì ‚ä¢ f : Œ†(x:M).N   Œì ‚ä¢ e : M
    -----------------------------
    Œì ‚ä¢ f e : N[x:=e]




            </code></pre>
        </section>

        <section>
            <h4>Dependent functional type | <code>&Pi;(x:M).N</code></h4>

            <center><p>type of return value varies with its argument</p></center>

            <pre><code class="language-ocaml" data-noescape>
    Œì, x : M ‚ä¢ b : N
    ----------------------
    Œì ‚ä¢ Œª(x).b : Œ†(x:M).N

    Œì ‚ä¢ f : Œ†(x:M).N   Œì ‚ä¢ e : M
    -----------------------------
    Œì ‚ä¢ f e : N[x:=e]

    Œì ‚ä¢ M : ?      Œì, x : M ‚ä¢ N : ?
    -----------------------------------
    Œì ‚ä¢ Œ†(x:M).N : ?
            </code></pre>
        </section>

        <section>
            <h4>Dependent functional type | <code>&Pi;(x:M).N</code></h4>

            <center><p>type of return value varies with its argument</p></center>

            <pre><code class="language-ocaml" data-noescape>
    Œì, x : M ‚ä¢ b : N
    ----------------------
    Œì ‚ä¢ Œª(x).b : Œ†(x:M).N

    Œì ‚ä¢ f : Œ†(x:M).N   Œì ‚ä¢ e : M
    -----------------------------
    Œì ‚ä¢ f e : N[x:=e]

    Œì ‚ä¢ M : type   Œì, x : M ‚ä¢ N : type
    -----------------------------------
    Œì ‚ä¢ Œ†(x:M).N : type
            </code></pre>
        </section>

        <section>
            <h4>Dependent functional type: simple example</h4>

            <pre><code class="language-ocaml" data-noescape>
    (* A ‚Üí B &equiv; Œ†(_:A).B *)

    sig id_t : ?
    val id_t = Œª(X).X ‚Üí X






            </code></pre>
        </section>

        <section>
            <h4>Dependent functional type: simple example</h4>

            <pre><code class="language-ocaml" data-noescape>
    (* A ‚Üí B &equiv; Œ†(_:A).B *)

    sig id_t : type ‚Üí type
    val id_t = Œª(X).X ‚Üí X






            </code></pre>
        </section>

        <section>
            <h4>Dependent functional type: simple example</h4>

            <pre><code class="language-ocaml" data-noescape>
    (* A ‚Üí B &equiv; Œ†(_:A).B *)

    sig id_t : type ‚Üí type
    val id_t = Œª(X).X ‚Üí X

    sig add : int ‚Üí int ‚Üí int




            </code></pre>
        </section>

        <section>
            <h4>Dependent functional type: simple example</h4>

            <pre><code class="language-ocaml" data-noescape>
    (* A ‚Üí B &equiv; Œ†(_:A).B *)

    sig id_t : type ‚Üí type
    val id_t = Œª(X).X ‚Üí X

    sig add : int ‚Üí int ‚Üí int

    sig incr : int ‚Üí int
    val incr = add 1

            </code></pre>
        </section>

        <section>
            <h4>Dependent functional type: simple example</h4>

            <pre><code class="language-ocaml" data-noescape>
    (* A ‚Üí B &equiv; Œ†(_:A).B *)

    sig id_t : type ‚Üí type
    val id_t = Œª(X).X ‚Üí X

    sig add : int ‚Üí int ‚Üí int

    sig incr : id_t int
    val incr = add 1

            </code></pre>
        </section>

        <section>
            <h4>Dependent functional type: intuitive example</h4>

            <pre><code class="language-ocaml" data-noescape>
    (* A ‚Üí B &equiv; Œ†(_:A).B *)

    sig select : int ‚Üí type
    (* with select 0 = string and select i = char for i != 0 *)






            </code></pre>
        </section>

        <section>
            <h4>Dependent functional type: intuitive example</h4>

            <pre><code class="language-ocaml" data-noescape>
    (* A ‚Üí B &equiv; Œ†(_:A).B *)

    sig select : int ‚Üí type
    (* with select 0 = string and select i = char for i != 0 *)

    sig aString : string
    val aString = "Hello World üëã"

    sig aChar   : char
    val aChar   = 'üòÄ'
            </code></pre>
        </section>

        <section>
            <h4>Dependent functional type: intuitive example</h4>

            <pre><code class="language-ocaml" data-noescape>
    (* A ‚Üí B &equiv; Œ†(_:A).B *)

    sig select : int ‚Üí type
    (* with select 0 = string and select i = char for i != 0 *)

    sig aString : select 0
    val aString = "Hello World üëã"

    sig aChar   : select 1
    val aChar   = 'üòÄ'
            </code></pre>
        </section>

        <section>
            <h4> Pairs </h4>
        </section>

        <section>
            <h4>Pair type | <code data-noescape>M * N</code></h4>

            <pre><code class="language-ocaml" data-noescape>
    Œì ‚ä¢ a : M   Œì ‚ä¢ b : N
    ----------------------
    Œì ‚ä¢ (a,b) : (M * N)

    Œì ‚ä¢ e : (M * N)         Œì ‚ä¢ e : (M * N)
    ----------------        ----------------
    Œì ‚ä¢ fst e : M           Œì ‚ä¢ snd e : N
            </code></pre>
        </section>

        <section>
            <h4>&lambda;3: Language &lambda;2 and dependant pair type</h4>

            <pre><code class="language-ocaml" data-noescape>
    e ::=
         ...
         e,e                    -- Pair
         fst e                  -- Left projection
         snd e                  -- Right projection

         ...
         e * e                  -- Pair type

            </code></pre>
        </section>

        <section>
            <h4>&lambda;3: Language &lambda;2 and dependant pair type</h4>

            <pre><code class="language-ocaml" data-noescape>
    e ::=
         ...
         e,e                    -- Pair
         fst e                  -- Left projection
         snd e                  -- Right projection

         ...
         e * e                  -- &equiv; Œ£(_:e).e
         Œ£(x:e).e               -- Dependent pair type
            </code></pre>
        </section>

        <section>
            <h4>Dependant pair type | <code data-noescape>Œ£(x:M).N</code></h4>

            <center><p>type of right value varies with its left value</p></center>

            <pre><code class="language-ocaml" data-noescape>
    Œì ‚ä¢ a : ?   Œì ‚ä¢ b : ?
    ---------------------------
    Œì ‚ä¢ a,b : ?

    Œì ‚ä¢ p : ?                 Œì ‚ä¢ p : ?
    -----------------         -----------------------
    Œì ‚ä¢ fst p : ?             Œì ‚ä¢ snd p : ?




            </code></pre>
        </section>

        <section>
            <h4>Dependant pair type | <code data-noescape>Œ£(x:M).N</code></h4>

            <center><p>type of right value varies with its left value</p></center>

            <pre><code class="language-ocaml" data-noescape>
    Œì ‚ä¢ a : M   Œì ‚ä¢ b : N
    ---------------------------
    Œì ‚ä¢ a,b : Œ£(x:M).N

    Œì ‚ä¢ p : ?                 Œì ‚ä¢ p : ?
    -----------------         -----------------------
    Œì ‚ä¢ fst p : ?             Œì ‚ä¢ snd p : ?




            </code></pre>
        </section>

        <section>
            <h4>Dependant pair type | <code data-noescape>Œ£(x:M).N</code></h4>

            <center><p>type of right value varies with its left value</p></center>

            <pre><code class="language-ocaml" data-noescape>
    Œì ‚ä¢ a : M   Œì ‚ä¢ b : N[x:=a]
    ---------------------------
    Œì ‚ä¢ a,b : Œ£(x:M).N

    Œì ‚ä¢ p : ?                 Œì ‚ä¢ p : ?
    -----------------         -----------------------
    Œì ‚ä¢ fst p : ?             Œì ‚ä¢ snd p : ?




            </code></pre>
        </section>

        <section>
            <h4>Dependant pair type | <code data-noescape>Œ£(x:M).N</code></h4>

            <center><p>type of right value varies with its left value</p></center>

            <pre><code class="language-ocaml" data-noescape>
    Œì ‚ä¢ a : M   Œì ‚ä¢ b : N[x:=a]
    ---------------------------
    Œì ‚ä¢ a,b : Œ£(x:M).N

    Œì ‚ä¢ p : Œ£(x:M).N          Œì ‚ä¢ p : ?
    -----------------         -----------------------
    Œì ‚ä¢ fst p : M             Œì ‚ä¢ snd p : ?




            </code></pre>
        </section>

        <section>
            <h4>Dependant pair type | <code data-noescape>Œ£(x:M).N</code></h4>

            <center><p>type of right value varies with its left value</p></center>

            <pre><code class="language-ocaml" data-noescape>
    Œì ‚ä¢ a : M   Œì ‚ä¢ b : N[x:=a]
    ---------------------------
    Œì ‚ä¢ a,b : Œ£(x:M).N

    Œì ‚ä¢ p : Œ£(x:M).N          Œì ‚ä¢ p : Œ£(x:M).N
    -----------------         -----------------------
    Œì ‚ä¢ fst p : M             Œì ‚ä¢ snd p : N




            </code></pre>
        </section>

        <section>
            <h4>Dependant pair type | <code data-noescape>Œ£(x:M).N</code></h4>

            <center><p>type of right value varies with its left value</p></center>

            <pre><code class="language-ocaml" data-noescape>
    Œì ‚ä¢ a : M   Œì ‚ä¢ b : N[x:=a]
    ---------------------------
    Œì ‚ä¢ a,b : Œ£(x:M).N

    Œì ‚ä¢ p : Œ£(x:M).N          Œì ‚ä¢ p : Œ£(x:M).N
    -----------------         -----------------------
    Œì ‚ä¢ fst p : M             Œì ‚ä¢ snd p : N[x:=fst p]




            </code></pre>
        </section>

        <section>
            <h4>Dependant pair type | <code data-noescape>Œ£(x:M).N</code></h4>

            <center><p>type of right value varies with its left value</p></center>

            <pre><code class="language-ocaml" data-noescape>
    Œì ‚ä¢ a : M   Œì ‚ä¢ b : N[x:=a]
    ---------------------------
    Œì ‚ä¢ a,b : Œ£(x:M).N

    Œì ‚ä¢ p : Œ£(x:M).N          Œì ‚ä¢ p : Œ£(x:M).N
    -----------------         -----------------------
    Œì ‚ä¢ fst p : M             Œì ‚ä¢ snd p : N[x:=fst p]

    Œì ‚ä¢ M : type   Œì, x : M ‚ä¢ N : type
    -----------------------------------
    Œì ‚ä¢ Œ£(x:M).N : type
            </code></pre>
        </section>

        <section>
            <h4>Dependent pair type: simple example</h4>

            <pre><code class="language-ocaml" data-noescape>
    sig pair : ?
    val pair = (char , 'ü§ü')






            </code></pre>
        </section>

        <section>
            <h4>Dependent pair type: simple example</h4>

            <pre><code class="language-ocaml" data-noescape>
    sig pair : (type * char)
    val pair = (char , 'ü§ü')






            </code></pre>
        </section>

        <section>
            <h4>Dependent pair type: simple example</h4>

            <pre><code class="language-ocaml" data-noescape>
    sig pair : Œ£(x:type).x
    val pair = (char , 'ü§ü')






            </code></pre>
        </section>

        <section>
            <h4>Dependent pair type: simple example</h4>

            <pre><code class="language-ocaml" data-noescape>
    sig pair : Œ£(x:type).x
    val pair = (char , 'ü§ü')

    sig first : type
    val first = fst pair



            </code></pre>
        </section>

        <section>
            <h4>Dependent pair type: simple example</h4>

            <pre><code class="language-ocaml" data-noescape>
    sig pair : Œ£(x:type).x
    val pair = (char , 'ü§ü')

    sig first : type
    val first = fst pair

    sig second : ?
    val second = snd pair
            </code></pre>
        </section>

        <section>
            <h4>Dependent pair type: simple example</h4>

            <pre><code class="language-ocaml" data-noescape>
    sig pair : Œ£(x:type).x
    val pair = (char , 'ü§ü')

    sig first : type
    val first = fst pair

    sig second : char
    val second = snd pair
            </code></pre>
        </section>

        <section>
            <h4>Dependent pair type: simple example</h4>

            <pre><code class="language-ocaml" data-noescape>
    sig pair : Œ£(x:type).x
    val pair = (char , 'ü§ü')

    sig first : type
    val first = fst pair

    sig second : char (* x[x:=fst pair] &Rightarrow; fst pair &Rightarrow; char *)
    val second = snd pair
            </code></pre>
        </section>

        <section>
            <h4>Dependent pair type: simple example</h4>

            <pre><code class="language-ocaml" data-noescape>
    sig pair : Œ£(x:type).x
    val pair = (char , 'ü§ü')

    sig first : type
    val first = fst pair

    sig second : fst pair
    val second = snd pair
            </code></pre>
        </section>

        <section>
            <h4>Sum</h4>
        </section>

        <section>
            <h4>&lambda;4: Language &lambda;3 and sum type</h4>

            <pre><code class="language-ocaml" data-noescape>
    x &in; Variables

    e ::=
         ...
         inl e                  -- Left injection
         inr e                  -- Right injection
         case x e e             -- Catamorphism

         ...
         e + e                  -- Sum type
            </code></pre>
        </section>

        <section>
            <h4>Sum type</h4>

            <pre><code class="language-ocaml" data-noescape>
    Œì ‚ä¢ a : ?                  Œì ‚ä¢ a : ?
    ------------------         ------------------
    Œì ‚ä¢ inl a : ?              Œì ‚ä¢ inr a : ?

    Œì ‚ä¢ a : ?
    Œì ‚ä¢ l : ?                    Œì ‚ä¢ r : ?
    --------------------------------------------------------
    Œì ‚ä¢ case a l r : P




            </code></pre>

        </section>

        <section>
            <h4>Sum type</h4>

            <pre><code class="language-ocaml" data-noescape>
    Œì ‚ä¢ a : M                  Œì ‚ä¢ a : N
    ------------------         ------------------
    Œì ‚ä¢ inl a : M + N          Œì ‚ä¢ inr a : M + N

    Œì ‚ä¢ a : ?
    Œì ‚ä¢ l : ?                    Œì ‚ä¢ r : ?
    --------------------------------------------------------
    Œì ‚ä¢ case a l r : P




            </code></pre>

        </section>

        <section>
            <h4>Sum type</h4>

            <pre><code class="language-ocaml" data-noescape>
    Œì ‚ä¢ a : M                  Œì ‚ä¢ a : N
    ------------------         ------------------
    Œì ‚ä¢ inl a : M + N          Œì ‚ä¢ inr a : M + N

    Œì ‚ä¢ a : M + N
    Œì ‚ä¢ l : Œ†(x:M).P             Œì ‚ä¢ r : Œ†(x:N).P
    --------------------------------------------------------
    Œì ‚ä¢ case a l r : P




            </code></pre>

        </section>

        <section>
            <h4>Sum type</h4>

            <pre><code class="language-ocaml" data-noescape>
    Œì ‚ä¢ a : M                  Œì ‚ä¢ a : N
    ------------------         ------------------
    Œì ‚ä¢ inl a : M + N          Œì ‚ä¢ inr a : M + N

    Œì ‚ä¢ a : M + N
    Œì ‚ä¢ l : Œ†(x:M).P[a:=inl x]   Œì ‚ä¢ r : Œ†(x:N).P[a:=inr x]
    --------------------------------------------------------
    Œì ‚ä¢ case a l r : P




            </code></pre>

        </section>

        <section>
            <h4>Sum type</h4>

            <pre><code class="language-ocaml" data-noescape>
    Œì ‚ä¢ a : M                  Œì ‚ä¢ a : N
    ------------------         ------------------
    Œì ‚ä¢ inl a : M + N          Œì ‚ä¢ inr a : M + N

    Œì ‚ä¢ a : M + N
    Œì ‚ä¢ l : Œ†(x:M).P[a:=inl x]   Œì ‚ä¢ r : Œ†(_:N).P[a:=inr x]
    --------------------------------------------------------
    Œì ‚ä¢ case a l r : P

    Œì ‚ä¢ M : Type    Œì ‚ä¢ N : Type
    -----------------------------
    Œì ‚ä¢ M + N : Type
            </code></pre>

        </section>

        <section>
            <h4>Sum type: simple example</h4>

            <pre><code class="language-ocaml" data-noescape>
    sig ic : int | char ‚Üí type
    val ic =  Œª(x).case x Œª(_).char Œª(_).int

    sig aChar : char
    val aChar = 'c'
            </code></pre>
        </section>

        <section>
            <h4>Dependent pair type: simple example</h4>

            <pre><code class="language-ocaml" data-noescape>
    sig ic : int | char ‚Üí type
    val ic =  Œª(x).case x Œª(_).char Œª(_).int

    sig aChar : ic (inl 1)
    val aChar = 'c'
            </code></pre>
        </section>

        <section>
            <h4>Sum type: advanced example</h4>

            <pre><code class="language-ocaml" data-noescape>
    sig Bool : type
    val Bool = Unit | Unit











            </code></pre>
        </section>

        <section>
            <h4>Sum type: advanced example</h4>

            <pre><code class="language-ocaml" data-noescape>
    sig Bool : type
    val Bool = Unit | Unit

    sig true  : Bool
    val true  = inl unit
    sig false : Bool
    val false = inr unit






            </code></pre>
        </section>

        <section>
            <h4>Sum type: advanced example</h4>

            <pre><code class="language-ocaml" data-noescape>
    sig Bool : type
    val Bool = Unit | Unit

    sig true  : Bool
    val true  = inl unit
    sig false : Bool
    val false = inr unit

    sig Test : Bool ‚Üí type
    val Test = Œª(b).case b Œª(_).int Œª(_).char



            </code></pre>
        </section>

        <section>
            <h4>Sum type: advanced example</h4>

            <pre><code class="language-ocaml" data-noescape>
    sig Bool : type
    val Bool = Unit | Unit

    sig true  : Bool
    val true  = inl unit
    sig false : Bool
    val false = inr unit

    sig Test : Bool ‚Üí type
    val Test = Œª(b).case b Œª(_).int Œª(_).char

    sig test : Œ†(b:Bool).?
    val test = Œª(c).case c Œª(_).1 Œª(c).'c'
            </code></pre>
        </section>

        <section>
            <h4>Sum type: advanced example</h4>

            <pre><code class="language-ocaml" data-noescape>
    sig Bool : type
    val Bool = Unit | Unit

    sig true  : Bool
    val true  = inl unit
    sig false : Bool
    val false = inr unit

    sig Test : Bool ‚Üí type
    val Test = Œª(b).case b Œª(_).int Œª(_).char

    sig test : Œ†(b:Bool).(Test b)
    val test = Œª(c).case c Œª(_).1 Œª(c).'c'
            </code></pre>
        </section>

        <section>
            <h4>Propositional Equality</h4>

            <p>Extentional</p>
        </section>

        <section>
            <h4>&lambda;5: Language &lambda;4 and propositional equality</h4>

            <pre><code class="language-ocaml" data-noescape>
    e ::=
         ...
         refl                   -- Reflexivity
         subst e by e           -- Substitution

         ...
         e = e                  -- Type equality
            </code></pre>
        </section>

        <section>
            <h4>Propositional equality</h4>

            <pre><code class="language-ocaml" data-noescape>
                              Œì ‚ä¢ n : A    Œì ‚ä¢ m : A
    -----------------         -----------------------
    Œì ‚ä¢ refl : m = m          Œì ‚ä¢ n = m : Type

    Œì ‚ä¢ b : x = B    Œì ‚ä¢ a : A[x:=B]
    ---------------------------------
    Œì ‚ä¢ subst a by b : A

    Œì ‚ä¢ b : B = x    Œì ‚ä¢ a : A[x:=B]
    ---------------------------------
    Œì ‚ä¢ subst a by b : A
            </code></pre>
        </section>

        <section>
            <h4>Propositional equality: simple example</h4>

            <pre><code class="language-ocaml" data-noescape>
    sig symmetric : &Pi;(A:type).&Pi;(a:A).&Pi;(b:A).(a = b ‚Üí b = a)
    val symmetric = &lambda;(_).&lambda;(a).&lambda;(b).&lambda;(a=b).(subst refl by a=b)
            </code></pre>
        </section>

        <section>
            <h4>Propositional equality: encoding GADT</h4>

            <pre><code class="language-ocaml" data-noescape>
    -{
     data Expr A =
     | Boolean of Bool with A = Bool
     | Integer of int  with A = int
    }-

    sig Expr : type ‚Üí type
    val Expr = &lambda;(A).(A = Bool * Bool) | (A = int * int)
            </code></pre>
        </section>

        <section>
            <h4>Propositional equality: open problem</h4>

            <h1 class="fragment">EQUALITY</h1>
        </section>

        <section>
            <h4>Not covered in this presentation</h4>

            <ul>
                <li>Implicits and simple type synthesis</li>
                <li>Dependent recursive type</li>
                <li>Dependent record type (&Sigma; type generalisation)</li>
                <li>Russell's Paradox</li>
            </ul>
        </section>

        <section>
            <h4>Russell's Paradox</h4>

            <center>R = { X &mid; X &notin; X }</center>

            <p>Introduction of a type hierarchy</p>

        </section>

        <section>
            <h3>Conclusion</h3>

            <p>Think Different!</p>
        </section>

        <section>
            <h4>Languages</h4>

            <ul>
                <li> Coq </li>
                <li> Agda </li>
                <li> Idris </li>
                <li> F* </li>
                <li> Lean </li>
                <li> ... </li>
                <li><a href="https://github.com/lambe-lang/nethra">Nethra</a></li>
            </ul>

        </section>

        <section>
            <h4>References</h4>

            <ul>
                <li><a href="https://hal.inria.fr/inria-00076024/document">The calculus of constructions</a>
                <li><a href="https://www.cse.chalmers.se/~bengt/papers/GKminiTT.pdf">A simple type-theoretic language: Mini-TT</a>
                <li><a href="http://www.cs.nott.ac.uk/~psztxa/publ/pisigma-new.pdf">Œ†Œ£: Dependent Types without the Sugar</a>
                <li><a href="https://dl.acm.org/doi/pdf/10.1145/289423.289451">Cayenne a language with dependent types</a>
                <li><a href="https://arxiv.org/pdf/2207.02129.pdf">Implementing Dependent Types in pi-forall</a>
                <li><a href="https://homotopytypetheory.org/book/">Homotopy Type Theory</a>
                <li><a href="https://nextjournal.com/zampino/russell-paradox">Russell's Paradox - Agda Edition</a></li>
            </ul>
        </section>

    </div>

</div>

<script src="revealjs/dist/reveal.js"></script>
<script src="revealjs/plugin/zoom/zoom.js"></script>
<script src="revealjs/plugin/notes/notes.js"></script>
<script src="revealjs/plugin/search/search.js"></script>
<script src="revealjs/plugin/markdown/markdown.js"></script>
<script src="revealjs/plugin/highlight/highlight.js"></script>
<script>

    // Also available as an ES module, see:
    // https://revealjs.com/initialization/
    Reveal.initialize({
        controls: false,
        progress: false,
        center: true,
        hash: true,
        transition: 'none',

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight]
    });

</script>

</body>
</html>
