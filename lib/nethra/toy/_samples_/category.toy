sig Functor : (M:type -> type) ->
    sig struct
        sig map : {a b:type} -> (a -> b) -> M a -> M b
    end

sig Apply : (M:type -> type) ->
    sig struct
        sig apply : {a b:type} -> M (a -> b) -> M a -> M b
    end

sig Applicative : (M:type -> type) ->
    sig struct with Apply M
        sig pure : {a:type} -> a -> M a
    end

sig Bind : (M:type -> type) ->
    sig struct
        sig bind : {a b:type} -> M a -> (a -> M b) -> M b
    end

sig Monad : (M:type -> type) ->
    sig struct with Bind M
        sig return : {a:type} -> a -> M a
    end

sig SemiGroupoid : (T:type -> type -> type) ->
    sig struct
        sig compose : {a b c:type} -> T a b -> T b c -> T a c
    end

sig Category : (T:type -> type -> type) ->
    sig struct with SemiGroupoid T
        sig identity : {a:type} -> T a a
    end
